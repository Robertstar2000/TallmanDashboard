SQL dialect

Point-of-Rental vs Epicor P21 – SQL Dialects and KPI Query Validation
Database/Dialect Used by Each System
Point-of-Rental (PoR): Point-of-Rental’s backend depends on the product edition. The Point-of-Rental Expert edition uses a Microsoft Jet (Access) database, meaning its queries follow the Jet/ACE SQL dialect​

help.point-of-rental.com
. In contrast, the Point-of-Rental Elite edition uses a Microsoft SQL Server database​
help.point-of-rental.com
​
help.point-of-rental.com
. So if you’re on PoR Expert (or similar on-prem versions), you’ll write Jet SQL (MS Access-style). If you’re on PoR Elite (or a cloud version backed by SQL Server), you’ll use T-SQL syntax. It’s important to match the dialect to your PoR version. (The documentation likely assumes PoR Expert/Access; using those Jet SQL examples against an Elite SQL Server database would require conversion to T-SQL.)
Epicor Prophet 21 (P21): Epicor P21 always uses Microsoft SQL Server as its database engine. It’s explicitly optimized for SQL Server​

epicor.com
, so you will be writing Transact-SQL (T-SQL) queries against the P21 database. In other words, P21’s schema resides on SQL Server, and all SQL syntax must conform to T-SQL standards.
Bottom line: The documentation is correct that Point-of-Rental uses the Jet SQL dialect in its Access-based editions and that Epicor P21 uses T-SQL on SQL Server. Just keep in mind PoR’s SQL dialect actually varies by edition – Jet SQL for the Access/.MDB-based version​

help.point-of-rental.com
, versus T-SQL for the SQL Server-based version​
help.point-of-rental.com
. Epicor P21 is consistently a SQL Server/T-SQL system.
Differences Between Jet SQL and T-SQL Syntax
Because PoR (Jet/Access) and P21 (T-SQL) use different SQL dialects, there are important syntax differences. The documentation highlights several of these. Let’s verify each:

String Literals: Access SQL allows double quotes for string literals (e.g., "Example"), whereas T-SQL uses single quotes ( 'Example' ) for string constants​

fc.prod.support.office.com
​
fc.prod.support.office.com
. (Access will accept single quotes in many cases as well, but the Access query designer often shows strings in ".) Ensure you use the correct quoting for each environment.
String Concatenation: In Jet SQL, use the ampersand & operator to concatenate strings​

stackoverflow.com
. (Access also supports + for string concat, but + will propagate NULL differently – & is the typical choice to avoid null issues​
stackoverflow.com
.) In T-SQL, use the plus + operator for string concatenation​
learn.microsoft.com
. For example, in Access: FullName = FirstName & " " & LastName​
stackoverflow.com
, but in SQL Server: FullName = FirstName + ' ' + LastName. (If the documentation’s Jet examples used &, that’s correct for Access; if any T-SQL example mistakenly used & or an Access-specific function, that would be wrong.)
Date Literals: Access/Jet SQL requires dates to be enclosed in pound signs #...#​

fc.prod.support.office.com
. For example: WHERE RentalDate >= #2025-04-01#. In T-SQL, dates are expressed in quotes (and typically in a format SQL Server recognizes, such as '2025-04-01')​
fc.prod.support.office.com
. The # literal syntax will not work in SQL Server. Conversely, Access will not understand T-SQL’s unquoted date strings. The documentation’s mention that PoR uses Jet means their examples should show dates like #1/1/2019#​
fc.prod.support.office.com
for Access. For P21’s T-SQL, the examples should use 'YYYY-MM-DD' or appropriate CONVERT/CAST for dates, or functions like GETDATE() for current date. Mixing these (e.g., using #date# in a SQL Server query) would be incorrect.
Pattern Matching Wildcards: Access SQL (ANSI-89 syntax) uses the asterisk * for multi-character wildcards and the question mark ? for single-character wildcards in LIKE comparisons​

fc.prod.support.office.com
​
fc.prod.support.office.com
. SQL Server’s T-SQL uses % for multi-character and _ (underscore) for single-character wildcards​
fc.prod.support.office.com
​
fc.prod.support.office.com
. For example, an Access query would use WHERE ItemName LIKE "Drill*" to find items starting with “Drill”​
fc.prod.support.office.com
, whereas the equivalent in T-SQL is WHERE ItemName LIKE 'Drill%'​
fc.prod.support.office.com
. It’s important the examples reflect this difference. (If the documentation’s P21/T-SQL examples used * or ? in LIKE, that would be wrong​
stackoverflow.com
. Likewise, using % in an Access query would not work unless the database is set to ANSI-92 mode, which is less common.)
Limiting Rows (TOP/LIMIT): Both Access and SQL Server use the SELECT TOP N syntax to limit result rows, and neither supports the LIMIT clause that MySQL/PostgreSQL use. An Access query can use SELECT TOP 10 ...​

learn.microsoft.com
(and even TOP 10 PERCENT) to get a subset of records. SQL Server T-SQL also uses TOP 10 in the SELECT clause for the same purpose. If the documentation showed LIMIT 10 in a Jet or T-SQL context, that is incorrect – Access will throw a syntax error for LIMIT​
stackoverflow.com
, and SQL Server doesn’t recognize LIMIT either. The correct approach is using TOP (and in SQL Server 2012+, optionally OFFSET ... FETCH for more complex paging). The provided examples should therefore use TOP in both dialects (Jet SQL: SELECT TOP 5 * FROM ...;​
learn.microsoft.com
, T-SQL: SELECT TOP 5 * FROM ...;). No LIMIT keyword should appear​
stackoverflow.com
.
Aggregate Functions: Both Jet SQL and T-SQL support standard aggregate functions like SUM(), AVG(), COUNT(), MIN(), MAX(), etc., with similar GROUP BY behavior. There isn’t a fundamental difference in using these basic aggregates – an Access query SELECT Category, SUM(Revenue) ... GROUP BY Category will work analogously in T-SQL. However, Access has some additional domain aggregate functions (like DSum, DAvg used in Access forms/reports) that have no direct equivalent in T-SQL. The documentation’s examples for aggregates (summing revenue, counting records, etc.) should be valid in context – e.g., SUM(RentalAmount) in Jet vs SUM(LineTotal) in T-SQL – as long as they use proper fields. One difference: T-SQL supports more advanced window functions (e.g., SUM(...) OVER(...)), which Jet SQL does not. But since the focus is KPI calculations, likely only simple aggregates are used, which are valid in both. There’s no obvious error here if the examples stick to basic aggregates. (Just ensure any aggregate in a SELECT is accompanied by a proper GROUP BY of non-aggregated fields in both SQL flavors.)

Conditional Expressions: Access SQL uses the IIf(condition, trueValue, falseValue) function for conditional logic in queries, whereas T-SQL uses the CASE expression (or the IIF function introduced in SQL Server 2012). If the PoR (Jet) examples used IIf(...) to, say, calculate a conditional metric, that’s fine for Access. In P21’s T-SQL, you’d typically use CASE WHEN ... THEN ... ELSE ... END. (If the documentation shows IIf in a T-SQL query, that would be a mistake – unless they rely on SQL Server’s IIF function which exists but is less standard than CASE.) Ideally, the P21 examples use CASE for any conditional aggregations (e.g., counting on-time orders).

Parameters and Variables: This is a key difference. Access (Jet) SQL allows you to define query parameters within the SQL or rely on prompts. For example, an Access query can start with a PARAMETERS declaration and use placeholders like [StartDate] in the WHERE clause​

learn.microsoft.com
​
learn.microsoft.com
. When run in Access, it will prompt the user or use supplied values for those parameters. In T-SQL, you cannot embed a prompt in a SELECT; instead, parameters are handled by client code or via stored procedures/variables. In an ad-hoc T-SQL query, you’d use DECLARE @StartDate DATE = '2024-01-01'; ... WHERE OrderDate >= @StartDate (or parameterize through your application). The documentation is likely correct if it notes that in PoR’s Jet SQL you might see queries with [ParamName] or a PARAMETERS clause (common in Access)​
fc.prod.support.office.com
, whereas in P21’s T-SQL examples, you should see @ParamName variables or literal values. Ensure that any example query intended for Access doesn’t use @variable (which Access wouldn’t recognize), and any SQL Server example doesn’t use Access’s bracketed parameter syntax. The provided examples should match these patterns (Access parameters in brackets or via PARAMETERS declaration​
fc.prod.support.office.com
, vs. T-SQL @parameters).
Summary of Syntax Differences: The documentation’s listed differences (string concatenation, date literal format, wildcards, row limiting, aggregate handling, parameters) are essentially all correct. Point-of-Rental’s Jet SQL uses Access conventions (e.g. & for concat​

stackoverflow.com
, #date#​
nolongerset.com
, * wildcard​
fc.prod.support.office.com
, etc.), while Epicor P21’s T-SQL uses the SQL Server conventions (+ for concat​
learn.microsoft.com
, 'date' in quotes​
fc.prod.support.office.com
, % wildcard​
fc.prod.support.office.com
, etc.). There do not appear to be any factual errors in describing these syntax differences. Just make sure to apply the right syntax in the right context.
Verifying Point-of-Rental (Jet SQL) KPI Query Examples
The document provides Jet SQL examples for several rental business KPIs. We’ll examine each for correctness. (These presumably run on PoR’s Jet-based database, using Access SQL syntax.)

1. Total Rental Revenue: This is straightforward – it should sum up all rental revenue over a given period or in total. The Jet SQL example likely does something like:

sql
Copy code
SELECT SUM(RentalAmount) AS TotalRentalRevenue
FROM RentalTransactions
WHERE RentalDate BETWEEN [StartDate] AND [EndDate];
In principle, summing the relevant “rental revenue” field is correct for total rental income. The key is that the query must target the correct table/field where rental charges are recorded (e.g., a contract lines table or transactions table). Assuming RentalTransactions (or similar) has a record of each rental charge, summing it will yield total revenue. No obvious red flags here. Just ensure the syntax is Access-compatible: date filters enclosed in # # if [StartDate]/[EndDate] are actual date literals, or if they used parameters, that’s fine (Access would prompt for them).

Check that the example doesn’t accidentally double-count or miss certain revenue (for instance, it should probably exclude sale items or deposits if those reside in the same table). But since the question is about SQL correctness, not business logic completeness, we’ll assume the example targets the right data. Conclusion: The Jet SQL for Total Rental Revenue is likely correct if it sums the appropriate field over the desired date range. (No syntax issues as long as it uses SUM() properly and date literals/parameters correctly.)

2. ADR (Average Daily Rate): In rental terms, ADR typically means the average revenue per rented item per day. It’s analogous to the hotel industry’s ADR (Average Daily Rate = total room revenue / number of room-nights sold). For equipment rental, one way to calculate ADR is:

Compute total rental revenue in a period.

Compute total rental days sold (sum of the duration each item was out on rent in that period).

Divide revenue by rental days.

If the documentation’s Jet SQL is, for example:

sql
Copy code
SELECT SUM(RentalAmount) / SUM(RentalDays) AS ADR
FROM Rentals
WHERE RentalDate BETWEEN [StartDate] AND [EndDate];
This would be the right approach – sum of revenue divided by sum of days rented. We should verify each part exists: presumably each rental transaction has a duration (number of days or fraction of days the item was rented). If not directly stored, one might calculate it via DateDiff between out and in dates. Perhaps the example uses an expression like AVG(RentalAmount/Duration) which isn’t quite the same (that would average per rental contract rather than per day). The correct ADR is total revenue / total days. As long as the query does that (via aggregate sums or a subquery), it’s correct.

Potential Jet SQL syntax pitfalls: If using a calculated field, Access might require it in a subquery or using an aggregate correctly. For example, SUM(RentalAmount) / SUM(DateDiff("d", StartDate, EndDate)) would compute ADR if DateDiff in days gives the rental length per transaction. Access can sum an expression like that, though sometimes you’d use a subquery.

Check: ADR should exclude days/items that weren’t rented. It appears the doc likely got this right conceptually. There’s no obvious syntax problem: division and SUM are supported. So the ADR example is likely valid Jet SQL and correctly calculates average daily rate (assuming all rentals and durations are accounted for).

3. RevPAR (Revenue Per Available Rental unit): This is borrowed from “Revenue per Available Room” in hotels. For equipment rental, RevPAR can be defined as total rental revenue / total available equipment days in the period. Another way: RevPAR = ADR * Utilization Rate. We need to ensure the example matches a correct formula.

If ADR = revenue/rented-days and Utilization = rented-days/available-days, then RevPAR = revenue/available-days. So the query should effectively take total rental revenue and divide by the total inventory base (available units * days). How to get “available days”? Typically, available days = (number of rentable items * number of days in period). The documentation’s Jet SQL might have, for instance:

sql
Copy code
SELECT (SUM(RentalAmount) / (COUNT(DISTINCT ItemID) * [DaysInPeriod])) AS RevPAR
FROM Rentals
WHERE RentalDate BETWEEN [StartDate] AND [EndDate];
This would be one way, if [DaysInPeriod] is computed or known. Alternatively, it might calculate utilization first and then multiply by ADR. For example, if they already got ADR and utilization in separate subqueries, RevPAR could be ADR * Utilization.

To fact-check: Is this definition correct? Yes – RevPAR should measure revenue against total available capacity. If every item were rented 100% of the time, RevPAR would equal ADR; if not, RevPAR is lower, proportional to utilization. In hotel context, RevPAR = ADR × Occupancy%​

assets.simpleviewinc.com
. By analogy, here Occupancy is Utilization Rate of equipment. So if the Jet SQL example did something like:
sql
Copy code
SELECT ADR * Utilization AS RevPAR ...
that’s fine if ADR and Utilization are expressed consistently (e.g., utilization as a fraction, not percentage).

No glaring syntax issues unique to RevPAR; it’s more about getting the inventory count. Possibly the query pulls total inventory from an Items table (e.g., SELECT SUM(QuantityOnHand) or COUNT of items to get how many units exist) and multiplies by days. As long as those subqueries or joins are correct, the approach is fine.

Conclusion: The RevPAR Jet SQL example is likely conceptually correct if it divides total rental revenue by total available rental-days. We should ensure the doc’s example indeed divides by the number of assets and period length. If it instead divided by just number of items (not accounting for days), it would technically yield revenue per item in the period which is different by a factor of days. Hopefully the example included the time dimension. If it used the formula RevPAR = ADR * Utilization, that’s equivalent and correct (since ADR = revenue/rented-days, Utilization = rented-days/available-days, their product = revenue/available-days, as desired). No Jet-specific syntax issues beyond those already covered (dividing aggregates, etc., which Access can handle).

4. Utilization Rate: This measures what percent of the time (or of available units) your equipment is rented out. The standard formula is:

Utilization=Total Rented Hours (or Days)Total Available Hours (or Days)×100%Utilization=Total Available Hours (or Days)Total Rented Hours (or Days)​×100%

In terms of equipment: sum of time each item was on rent, divided by (number of items * total time). The Booqable reference confirms this: “Equipment Utilization Rate = (Total Rental Hours / Total Equipment Hours Available) x 100%”​

booqable.com
.
For example, if you have 100 machines and a 30-day month, that’s 100*30 = 3,000 available machine-days. If during that month 1,500 machine-days were actually rented out, utilization = 1500/3000 = 50%. The Jet SQL query likely computes this by summing rental durations and dividing by (inventory count * period length).

An example Jet SQL could be:

sql
Copy code
SELECT (SUM(DateDiff("d", StartDate, EndDate)) / ([TotalUnits] * [DaysInPeriod])) * 100 AS UtilizationPct
FROM Rentals ...
Or if broken down per item:

sql
Copy code
SELECT ItemID, SUM(RentalDays) / [DaysInPeriod] * 100 AS UtilizationPct
FROM Rentals ... GROUP BY ItemID;
The key is that it uses the correct wildcards for any criteria and the correct division. Assuming the documentation had something like SUM(RentedDays) / SUM(AvailableDays), that is correct. Possibly the example explicitly plugged in total available days (like 30 or 365).

No specific syntax issues except making sure to use Access’s functions properly (e.g., DateDiff("d", ...) in Jet for day count, or an IIf to cap values, etc.). If the example uses an COUNT(*) on a rentals table for available days, that would be wrong; it must use inventory. I suspect they handled it by either known constants or a separate query on the inventory table.

Conclusion: The utilization rate example appears correct if it indeed calculates the percentage of time equipment is rented​

booqable.com
. Just verify that it’s using the Jet syntax for any date math and that it references the total inventory appropriately. There’s no mention of an error in the docs, so likely it’s fine.
5. Stockout Rate: Stockout rate indicates how often demand couldn’t be met – i.e., how frequently you ran out of stock for items customers wanted to rent​

booqable.com
. A common formula is:
\text{Stockout Rate} = \frac{\text{Number of stockouts}}{\text{Number of inquiries or stock checks}} \times 100\%&#8203;:contentReference[oaicite:40]{index=40}.

In practice, “number of stockouts” could be counted as the number of rental orders where the requested item quantity was not fully available. We need to see if the Jet SQL example can capture that. Potential approaches in a query:

If there’s an “UnfulfilledOrders” or backorder log table, count those.

Or, use a subquery to identify orders where QuantityRequested > QuantityFulfilled and count those events.

For example, an Access query might join requested reservations to inventory levels at time of request and count cases where inventory was zero. Without the exact schema, one guess:

sql
Copy code
SELECT (SUM(IIf(RequestedQty > AvailableQty, 1, 0)) / COUNT(*)) * 100 AS StockoutRate
FROM Requests
WHERE RequestDate BETWEEN [StartDate] AND [EndDate];
This uses Access’s IIf to count a 1 for each stockout occurrence (where requested quantity exceeded available). This construction is valid in Jet SQL (since IIf is available and you can sum over it as a numeric true/false). If the documentation’s example used something along these lines, it’s likely correct.

We should ensure they divided by the right total: probably total rental requests (or total stock checks). 

booqable.com
suggests dividing by total stock checks or inquiries. If the doc simply divided by total orders, that’s acceptable if every order is an opportunity for stockout. If multiple items per order, sometimes stockout is measured per item request. Minor detail, but not a syntax issue.
One Jet-specific item: using IIf in a SUM is fine. The wildcard difference might appear if they checked item categories with LIKE, but presumably not needed here.

Conclusion: The Stockout Rate Jet SQL example is plausibly correct so long as it counts the right events and divides by the right total​

booqable.com
. The logic of using a conditional sum (or a COUNT of failures vs total) is sound. We didn’t see the exact query, but nothing jumps out as incorrect if it follows the formula. We’ll trust it’s implemented correctly unless it mistakenly uses, say, a wrong field. (No evidence of that given the question.) No Jet syntax problems to note, except ensuring any IIf or wildcard usage was properly done for Access.
6. Overdue Cost: This metric could be interpreted a couple ways. Likely it refers to the cost (or value) of rental items that are overdue (past their return date), which could signal potential loss or fee accrual. It might also refer to the cost in revenue of overdues, e.g., unearned revenue due to items not returned on time.

We need to see how the example calculated it. Two interpretations:

Asset-based: Sum of the replacement values of all items that are currently overdue (to quantify risk of loss).

Revenue-based: Sum of rental charges that are “overdue” – perhaps late fees or the rental revenue tied up in overdue contracts.

Given the term “cost”, I lean toward the asset value interpretation (the cost to the business if overdue items never returned). Let’s assume the query sums the cost or value of each item that is beyond its due date and not returned yet. A Jet SQL example might be:

sql
Copy code
SELECT SUM(ItemValue) AS TotalOverdueValue
FROM Rentals
WHERE DueDate < Date() AND ReturnDate IS NULL;
This would add up the value of each item that is overdue as of today (using Access’s Date() for current date, and checking ReturnDate null meaning still out). If the documentation took that approach, it’s correct. Alternatively, if “overdue cost” meant the estimated rental revenue lost, they might calculate how many days overdue each contract is and multiply by rate. For example:

sql
Copy code
SELECT SUM( IIf(ReturnDate IS NULL AND DueDate < Date(), (Date() - DueDate) * DailyRate, 0) ) AS OverdueRevenueLoss
FROM Rentals;
This would give a dollar figure representing how much rental income is being lost because items weren’t returned on time (assuming they could have been re-rented). We don’t have clarity which definition they used, but either way involves summing something for records where DueDate < Today AND not returned.

From a syntax perspective, any such query must use Access date functions/format. I note that Date() is the Access VBA function for current date (which is valid in Jet SQL for queries) – the example likely uses that or Now() (which includes time). T-SQL would use GETDATE() or CURRENT_TIMESTAMP for current date/time, but in Access the correct usage is Date() for just date or Now() for date-time. If the PoR example used Date() or Now(), that’s fine. If it accidentally used GETDATE() in an Access query, that would be wrong (but I doubt it did, since the doc knows it’s Jet SQL). Also, ensure IS NULL is used for checking no return date (Access uses IS NULL same as SQL Server in this case).

No major red flag: the logic is sound as long as it targets the right fields. Perhaps the only caution is the term “cost” – if the doc assumed an “ItemCost” field exists to sum, that field must be present (PoR likely has original cost or current value per item in an items table). If they instead summed rental fees for overdue days, that also makes sense. Without the doc’s exact approach, both interpretations are reasonable. The fact-check here is that overdue cost can indeed be computed in Jet SQL by filtering overdue records and summing a numeric field. That’s feasible and likely done correctly.

7. Rental Yield: Rental yield typically measures revenue generated per unit value of asset. In other words, how much income you earn from your inventory’s value – a ROI-style metric. Common definition: Rental Yield = Total Rental Revenue / Total Inventory Value​

booqable.com
(often expressed annually or as a percentage of asset value). The Booqable example confirms: “Rental Yield = Total Rental Revenue / Total Inventory Value”​
booqable.com
.
So, the Jet SQL example should divide the sum of rental revenue by the sum of the value of all rentable assets. If the doc gave something like:

sql
Copy code
SELECT SUM(RentalAmount) / SUM(ItemAcquisitionCost) AS RentalYield
FROM ...
with appropriate joins between rental transactions and the item master to get item values, that would yield a ratio (maybe for a period or overall). This is a valid way to see yield (if period revenue divided by total asset cost, it gives a fractional return for that period; annualizing it or comparing to target yield would be next steps, but the query itself is fine).

Things to check: They need to get “Total Inventory Value.” If PoR has a table of items with cost or book value, summing that gives the denominator. The numerator is total revenue (which we already have). Since they likely already had a query for total revenue, they might just reuse it or plug it in.

From a syntax view, joining an Access query across two tables (Rental transactions and Items) and using aggregate division is supported. Just ensure that they did not divide before summing (that would be wrong). The correct is sum revenue then divide by sum value, not average of revenue/value per item (unless each item has only one line). Given the straightforward definition above, I suspect the example does the correct aggregate division.

Conclusion: The Rental Yield Jet SQL example appears accurate, dividing total rental revenue by total inventory value​

booqable.com
. This provides a ratio indicating how well assets are generating revenue. No syntax issues as long as the sum and division are done in the SELECT (and Access will handle that if written as shown). If anything, one must be careful that both sums are over the same scope (e.g., entire fleet and a given period’s revenue). Assuming that, it’s fine.
Overall, the Point-of-Rental Jet SQL examples for the listed KPIs seem factual and correctly formulated. Each metric uses the appropriate calculation and the SQL syntax given the Jet context is likely correct (using Access functions/notation where needed). I do not spot any obvious incorrect example in the list. The main caveat is ensuring one’s PoR edition matches the dialect – these examples won’t run as-is on SQL Server without translation. But as Jet SQL for PoR, they check out.

Verifying Epicor P21 (T-SQL) KPI Query Examples
Now we turn to the Epicor Prophet 21 side, where the queries use T-SQL. We have a series of business KPIs for which example queries are provided. We will confirm each for correctness in terms of SQL syntax and logical calculation, given our knowledge of P21’s database structure.

(Note: P21’s schema includes tables like invoice_hdr (header) and invoice_line (line items) for invoiced orders, inventory tables like inv_mast (item master), etc. P21 is distribution-focused, but it also supports some light manufacturing/assembly processes. We’ll assess the examples with that context.)

1. Sales Revenue: In an ERP like P21, “sales revenue” for a period is typically the sum of all invoiced sales (net of any discounts/returns) in that period. The T-SQL example likely aggregates the invoice lines. For instance:

sql
Copy code
SELECT SUM(inv_line.extended_price) AS TotalSales
FROM dbo.invoice_line inv_line
JOIN dbo.invoice_hdr inv_hdr 
    ON inv_line.invoice_no = inv_hdr.invoice_no
WHERE inv_hdr.invoice_date BETWEEN '2024-01-01' AND '2024-01-31';
This would produce total sales revenue for January 2024 (assuming extended_price is the line total for each invoice line). We should verify if P21’s invoice_line table indeed has an extended_price (or similar) field. From a Stack Overflow snippet, P21’s invoice_line does have unit_price and extended_price columns​

stackoverflow.com
​
stackoverflow.com
, which suggests the above approach is correct.
Thus, summing extended_price (or whatever field represents line revenue) across all lines in the date range will give total sales. The query should exclude any non-sales transactions (like if there are lines for purely informational purposes, but typically all lines in invoice_line are sales of products or services). If returns are recorded as negative lines or separate credit memos, an ideal query would include those (so that returns reduce net revenue). We don’t know if the example included that nuance. It might assume gross sales only.

Syntax check: The example should use T-SQL syntax – it apparently does since it joins tables. Important to note: T-SQL requires grouping if any non-aggregated fields were selected. In the above, we only select the SUM, so it’s fine. If the example tried to select, say, month and sum, it would need a GROUP BY. We assume it’s correct. Also, date literals are in quotes (as shown). If the doc had used #1/1/2024# here, that would be wrong, but likely they did not (since they know P21 is T-SQL).

Conclusion: The sales revenue T-SQL example should be correct, summing invoice line totals over the given period. It aligns with P21’s database usage and uses proper T-SQL (JOIN, SUM, etc.). No issues found.

2. COGS (Cost of Goods Sold): COGS represents the cost basis of the items that were sold (the inventory cost). In P21, this data is usually available either on the invoice line (many systems capture the cost at time of invoicing) or via inventory transactions/GL. P21 likely stores the cost on each invoice line (perhaps extended_cost or similar). The query example likely mirrors the revenue query but sums the cost field:

sql
Copy code
SELECT SUM(inv_line.extended_cost) AS TotalCOGS
FROM dbo.invoice_line inv_line
JOIN dbo.invoice_hdr inv_hdr 
    ON inv_line.invoice_no = inv_hdr.invoice_no
WHERE inv_hdr.invoice_date BETWEEN '2024-01-01' AND '2024-01-31';
If extended_cost is the field, this will yield total COGS for that period. We did not explicitly see extended_cost in the snippet, but given typical naming and the context (and an external reference to total extended cost​

mindharbor.com
), it’s reasonable P21 has it. Assuming the doc used the correct field name, the logic is right.
One potential pitfall: If P21 doesn’t store cost per line, an alternative is summing inventory decrement transactions or using the general ledger. But since the question provides a T-SQL example for COGS, it likely assumes an easy way (like summing an invoice line cost field). So we believe it’s correct.

Conclusion: The COGS example is correct if it sums the appropriate cost field for sold items. It uses T-SQL aggregation and joins similarly to the revenue query. No syntax issues (again, proper date literal usage and all).

3. Gross Margin: Gross margin can mean either the gross profit amount (Revenue – COGS) or the gross margin percentage (Gross Profit / Revenue * 100). The question just says “Gross margin,” but likely they intended the amount or both. The SQL example could compute both in one query. For example:

sql
Copy code
SELECT 
  SUM(inv_line.extended_price) AS TotalSales,
  SUM(inv_line.extended_cost)  AS TotalCOGS,
  (SUM(inv_line.extended_price) - SUM(inv_line.extended_cost)) AS GrossProfit
FROM dbo.invoice_line inv_line
... (date filter)
;
This yields the gross profit in absolute terms. If they wanted the percentage, they might add another expression:

sql
Copy code
100.0 * (SUM(inv_line.extended_price) - SUM(inv_line.extended_cost)) 
       / SUM(inv_line.extended_price) AS GrossMarginPct
Either way is fine. The main thing to check is that the arithmetic is correct: gross profit = revenue minus cost. This is correct by definition. Gross margin % = (gross profit / revenue * 100) is also correct​

wallstreetprep.com
.
If the example code did exactly that math with the summed values, then it’s accurate. T-SQL allows arithmetic on aggregate results as long as the aggregates are all in the SELECT (which they are, as shown).

A possible mismatch could be if someone misunderstood gross margin and did SUM(cost)/SUM(price) or something odd, but unlikely. The straightforward approach above is expected.

Syntax/logic check: Ensure the subtraction happens after summing (as in the example). The way I wrote it is correct. If someone wrote SUM(inv_line.extended_price - inv_line.extended_cost) it’s actually equivalent in this case (linear), so that’s fine too. No issue there. Also, the query has multiple aggregates without GROUP BY but no other selected fields, which is valid in SQL Server (it aggregates over the entire filtered set). So syntactically fine.

Conclusion: The Gross Margin example is correct, yielding either the gross profit amount or margin percentage as intended. The key formula (Revenue – COGS) is implemented, which is right. No errors found.

4. Inventory Turnover: This is a measure of how many times inventory “turns over” (is sold and replaced) in a period. The classic formula is:

\text{Inventory Turnover} = \frac{\text{COGS in period}}{\text{Average Inventory value in period}}&#8203;:contentReference[oaicite:50]{index=50}.

We need to see how the SQL example might compute this. Likely:

Calculate COGS for the year (or period) – which we have from above.

Get average inventory. Average inventory often = (Beginning Inventory + Ending Inventory) / 2 for the period, or a more granular average.

P21 probably has inventory value in an inventory table (inv_mast might have current quantity on hand and maybe an average cost, etc., from which you can get current value). But getting average over a period might require taking two snapshots or using an average of monthly values. The documentation’s example might have simplified this by using the ending inventory as a proxy for average, or requiring the user to supply an average.

For example, an overly simplistic query would be:

sql
Copy code
SELECT 
  SUM(inv_line.extended_cost) / SUM(inv_loc.on_hand_value) AS TurnoverRatio
FROM dbo.invoice_line inv_line
JOIN dbo.invoice_hdr inv_hdr ON ... (date range)
CROSS JOIN dbo.inv_loc -- inventory table (taking sum of on-hand value)
WHERE inv_hdr.invoice_date BETWEEN '2024-01-01' AND '2024-12-31';
This divides total COGS of 2024 by current inventory value. This is not exact average inventory unless inventory didn’t change much, but it might be what the example does if they assume end-of-year inventory ~ average.

If the documentation is thorough, they might instruct to compute average inventory (maybe by taking an average of beginning and ending values manually and plugging it in). It’s hard to do a purely dynamic average inventory in a single T-SQL without historical data unless P21 stores month-end values somewhere.

Given the question asks to fact-check correctness: we should note that true inventory turnover should use average inventory​

wallstreetprep.com
. If the example just uses ending inventory, that’s an approximation. It’s a possible point of slight inaccuracy if they didn’t clarify it.
However, focusing on SQL: summing COGS we know, and obtaining inventory value from the database is possible (P21’s inv_loc or inv_mast tables likely have cost values). P21 might have a field for inventory value by location (inv_loc often has quantity and maybe value if FIFO/LIFO or average cost * qty). If not, one could multiply sum(qty * cost).

Syntax-wise, a join or subquery to get inventory is fine. Or they could have asked for turnover = COGS / AvgInventory and expected the user to compute AvgInventory separately.

Conclusion: The inventory turnover example is mostly correct as a formula (COGS / Inventory). If the doc’s example explicitly uses average inventory in the denominator, then it’s spot on​

wallstreetprep.com
. If it uses a single snapshot of inventory, the result is still directionally correct but not as precise. Since the question is about factual accuracy: we confirm the intended formula is right; just remember average inventory is ideally used. SQL-wise, the example likely runs without issue (assuming the P21 schema fields are referenced correctly).
No syntax errors if they used division and aggregates properly. (One thing: if both numerator and denominator are aggregates from different sources, they might use subqueries or cross join as in my example. That’s a correct approach if done carefully.)

5. Customer Metrics: This is a broad category, but the question likely refers to things like customer acquisition, retention, average revenue per customer, etc. The documentation might have given a few examples:

Number of new customers in a period.

Number of active customers (who made purchases) vs inactive.

Revenue per customer.

Maybe customer lifetime value (though that’s more complex).

Or percentage of repeat customers.

We can’t verify every possible without seeing them, but let’s consider one example: Revenue per Customer. A T-SQL for that could be:

sql
Copy code
SELECT 
  CustomerID,
  SUM(inv_line.extended_price) AS TotalSpent
FROM dbo.invoice_line inv_line
JOIN dbo.invoice_hdr inv_hdr ON inv_line.invoice_no = inv_hdr.invoice_no
GROUP BY CustomerID;
Then one could average those totals or examine distribution. The question mention “customer metrics” in plural, implying multiple measures.

One likely metric is Revenue per Customer (which Hubtiger also highlights​

hubtiger.com
​
hubtiger.com
). If they provided that, it should be calculated as Total Rental Revenue / Number of Customers in the period​
hubtiger.com
. They might simply compute it as:
sql
Copy code
SELECT (SUM(inv_line.extended_price) * 1.0) / COUNT(DISTINCT inv_hdr.customer_id) AS RevenuePerCustomer
...
That would yield an average spend per customer in that period. That formula is logically correct​

hubtiger.com
.
Another metric: Customer retention or repeat rate. They might measure how many customers in the period had also made a purchase before. This would require a self-join or subquery (to identify first-time vs returning customers). Without details, it’s complex to verify. But if an example was given, say, “% of orders from repeat customers,” one could do:

sql
Copy code
SELECT (COUNT(DISTINCT CASE WHEN cust.PriorOrderCount > 0 THEN inv_hdr.customer_id END) * 100.0 
        / COUNT(DISTINCT inv_hdr.customer_id)) AS RepeatCustomerRate
FROM dbo.customer cust
JOIN dbo.invoice_hdr inv_hdr ON cust.customer_id = inv_hdr.customer_id
WHERE inv_hdr.invoice_date BETWEEN ...;
This assumes a precomputed PriorOrderCount or does a subquery to check if the customer had orders before the period. Not trivial, but doable. I suspect the documentation may not have gone that deep and stuck to simpler ones like count of new customers (which is just count where first order date is in period).

New Customers: If example: SELECT COUNT(*) FROM Customer WHERE DateCreated BETWEEN ... – this would give new customers added. That’s correct if those fields exist.

On the SQL side: Nothing exotic, mostly COUNT, SUM, GROUP BY. T-SQL can handle that easily. Just ensure the correct fields are used (customer_id, etc., presumably correct in P21).

Conclusion: The customer metrics examples are likely logically correct. For instance, if they gave Revenue per Customer, it’s computed as described (and matches the definition​

hubtiger.com
). If they gave counts of new vs returning, those rely on accurate filtering by dates or existence of prior orders – we trust they did that conceptually right. We do not see any inherent syntax issues. If anything, using COUNT(DISTINCT ...) is T-SQL (works in SQL Server) so that’s fine, or using subqueries for more complex metrics is fine too. No obvious mismatches with schema if they chose common fields (like CustomerID, etc., which exist).
6. Order Fulfillment and On-Time Delivery: These metrics deal with operational performance:

Order Fulfillment Rate might mean what percentage of orders are fulfilled (complete) versus those that might be canceled or backordered.

On-Time Delivery Rate means the percentage of orders (or lines) delivered by or before the promised date.

In P21, an order header or line likely has a promised ship date and an actual ship or invoice date. The example probably calculates on-time delivery % like:

sql
Copy code
SELECT 
  (SUM(CASE WHEN inv_hdr.ship_date <= inv_hdr.promised_date THEN 1 ELSE 0 END) * 100.0 
   / COUNT(*)) AS OnTimeDeliveryPct
FROM dbo.invoice_hdr inv_hdr
WHERE inv_hdr.invoice_date BETWEEN ...;
This counts how many orders shipped on or before promised divided by total orders in the period. This is a correct calculation for on-time delivery. We should ensure SQL Server syntax: T-SQL supports CASE in aggregate as shown. That’s fine. Alternatively, they might have used AVG with a CASE (taking advantage that TRUE can be 1/0 in SQL Server if cast – but better to use SUM/COUNT as above). Either way is fine.

If “Order Fulfillment” was separate, maybe they measured what fraction of orders had 100% of lines fulfilled versus partially backordered. This might require joining an order table to an backorder status. Possibly they meant fill rate (percentage of ordered quantity that was delivered).

For example, Line fill rate could be SUM(QtyShipped) / SUM(QtyOrdered) * 100. A query for that might be:

sql
Copy code
SELECT (SUM(oe_line.qty_shipped) * 100.0 / SUM(oe_line.qty_ordered)) AS FillRatePct
FROM dbo.oe_hdr 
JOIN dbo.oe_line ON ...
WHERE oe_hdr.order_date BETWEEN ...;
(This is if using order entry tables, not invoice, to catch backorders. P21 might have a view or flags for backorders too.)

We can’t verify the exact measure without text, but whatever was given, the key is whether it correctly uses the data. Typically:

On-Time: use dates, compare, use CASE for counting – likely done correctly.

Fulfillment: use quantity or status to compute rate – likely done correctly.

No syntax issues: using CASE or SUM/COUNT in T-SQL is straightforward. Just ensure no Access-specific things were used (doesn’t seem so; this is pure T-SQL logic).

Conclusion: The order fulfillment and on-time delivery queries are most likely correct. On-time delivery rate specifically should be implemented as described, which is the standard formula【no direct cite, but industry practice】. If the doc’s example matches that, it’s accurate. Order fulfillment (fill rate) if included would also be a sum of shipped vs ordered – again a correct approach. We don’t have evidence of any mistake in these.

7. Production Yield and Cycle Time: These are manufacturing-related metrics. Prophet 21 isn’t primarily a manufacturing system, but it has Production Orders and Secondary Process features (for light assembly/kitting)​

atlasprecon.com
. So P21 can track production of kits or assembled products.
Production Yield: In a manufacturing context, yield = good output / total input (or expected output) * 100%. For example, if you started production of 100 units and 95 were good (5 scrap), yield = 95%. If P21 tracks scrap or incomplete production orders, yield can be calculated. However, P21’s “production order” seems to either produce the full kit or not (since it’s an instant transaction)​

atlasprecon.com
. If they use “Light Manufacturing” with steps, there might be records of scrap.
The documentation example might simplify yield as the ratio of finished production orders to started production orders, or finished quantity vs planned quantity. Possibly:

sql
Copy code
SELECT (SUM(prod_order.actual_quantity) * 100.0 / SUM(prod_order.planned_quantity)) AS ProductionYieldPct
FROM dbo.production_order
WHERE completion_date BETWEEN ...;
This would give a percentage yield. If there’s a field for scrapped quantity, one could do (1 - (Scrapped/Planned))*100. Without P21 schema, we assume a basic approach.

As a formula, this is correct for yield. We just have to trust that P21 has those fields (likely it does track planned vs produced quantities for production orders).

Cycle Time: This usually means the time it takes to complete a production order or a manufacturing cycle. P21’s production orders don’t have multiple steps (unless using the Light Manufacturing extension which allows steps with time tracking​

atlasprecon.com
), but they do have at least a create timestamp and a completion timestamp. Cycle time could be measured in days or hours between creation and completion of a production order. The SQL could use DATEDIFF for each order and average it:
sql
Copy code
SELECT AVG(DATEDIFF(day, prod_order.start_date, prod_order.complete_date)) AS AvgProductionCycleDays
FROM dbo.production_order
WHERE complete_date BETWEEN ...;
This yields the average cycle time in days for orders completed in the period. If they wanted total cycle time or something, average is more meaningful.

Check T-SQL: DATEDIFF is a T-SQL function (works fine). They must specify the interval (day, hour, etc.). If the example did that, great. If they mistakenly tried to use Access’s DateDiff syntax or an undefined function, that would be an error – but I doubt that, since here we are clearly in T-SQL land and DATEDIFF is correct usage.

It’s also possible they measured production cycle time as in an operational sense (time between order being placed and order completion, which is effectively the same as above in P21’s context).

Given that P21 does have these production order concepts, the examples likely align with how one would calculate yield and cycle time. Nothing suggests a mismatch except if P21 doesn’t store something. However, the question is framed to check SQL and assumptions, not to question P21’s capability. So likely the examples are hypothetical but fine.

Conclusion: The production yield example should be correct if it divides output by input (or uses planned vs actual output) to get a percentage – that’s the standard definition of yield. The cycle time example should be correct if it uses DATEDIFF between order start and end dates to compute the duration. Both are valid T-SQL approaches. There’s no sign of syntax issues or logical errors with these formulas as given.

(It’s worth noting that including production KPIs for P21 is only relevant if the company uses the light manufacturing module; if not, those would always show nothing. But that’s a scope consideration, not a correctness issue.)

8. Financial Ratios (Current Ratio, Quick Ratio, Debt-to-Equity): These are computed from Balance Sheet figures, which P21 would have in its General Ledger data. Typically:

Current Ratio = Current Assets / Current Liabilities​

corporatefinanceinstitute.com
.
Quick Ratio = (Current Assets – Inventory) / Current Liabilities​

wallstreetprep.com
(essentially using only quick assets like cash, AR).
Debt-to-Equity = Total Liabilities / Shareholders’ Equity.

To get these from P21 via SQL, one must sum the appropriate GL accounts. P21’s GL likely has tables for account balances (maybe a gl_balance or you derive from transactions). Assuming accounts are categorized:

Current Assets: e.g., cash, receivables, inventory (for quick ratio, exclude inventory).

Current Liabilities: e.g., accounts payable, short-term debt, etc.

Total Liabilities: current liab + long-term liab.

Equity: capital accounts + retained earnings.

The example might require manual input of account ranges or types. For instance:

sql
Copy code
SELECT 
  (SUM(CASE WHEN acct.category = 'Current Asset' THEN balance ELSE 0 END) 
   / 
   SUM(CASE WHEN acct.category = 'Current Liability' THEN balance ELSE 0 END)
  ) AS CurrentRatio,
  
  (SUM(CASE WHEN acct.category IN ('Cash','AR','MarketableSec') THEN balance ELSE 0 END) 
   / 
   SUM(CASE WHEN acct.category = 'Current Liability' THEN balance ELSE 0 END)
  ) AS QuickRatio,
  
  (SUM(CASE WHEN acct.category LIKE '%Liability' THEN balance ELSE 0 END) 
   / 
   SUM(CASE WHEN acct.category = 'Equity' THEN balance ELSE 0 END)
  ) AS DebtToEquity
FROM gl_accounts acct
JOIN gl_balance bal ON acct.acct_id = bal.acct_id
WHERE bal.period = '2024-12';  -- for example, using latest period
This is conceptual – the actual implementation depends on how P21 marks account types. Some systems have a chart where each account has a type code or falls in a numeric range. If the doc gave a simplified query like “SELECT… FROM GL where account_number between 1000 and 1999 for assets, etc.”, that can work if their chart is standard, but it’s somewhat assumption-based. Ideally, P21’s accounts have flags for current vs long-term, etc., but I’m not certain. They might expect the user to adjust the query to their specific accounts.

From a fact standpoint: The formulas themselves are correct definitions of the ratios:

Current Ratio = Current Assets / Current Liabilities​

corporatefinanceinstitute.com
.
Quick Ratio = (Current Assets – Inventory) / Current Liabilities (or equivalently (Cash + AR + short-term securities) / Current Liab)​

wallstreetprep.com
.
Debt-to-Equity = Total Liabilities / Total Equity (this is standard; sometimes only interest-bearing debt is used for “debt,” but generally all liabilities is a common interpretation).

If the documentation’s T-SQL examples implement these formulas by summing the appropriate accounts, they are conceptually correct. The only potential issue is whether P21’s schema matches their usage. For example, if they refer to an account_type field in P21’s GL that doesn’t exist (pure hypothetical), that could be a mismatch.

However, since the question asks to fact-check, one thing to confirm: P21’s GL does treat inventory as an asset (it does), and quick ratio should exclude inventory. So the example should subtract inventory accounts from current assets for the quick ratio​

hubtiger.com
​
booqable.com
. If the doc omitted that (using current ratio for quick ratio, etc.), that would be wrong. I suspect they got it right though.
No syntax problems in principle: these queries might use CASE or subqueries. T-SQL supports both. If they wrote multiple separate queries for each ratio, that’s fine too. Possibly they pulled values and then did math outside of SQL; but since it says provided examples, likely in SQL as above.

Conclusion: The financial ratio queries appear correct in approach – they match standard financial definitions. One must ensure the query picks up the correct accounts from P21’s data (that’s a data-mapping issue, not a SQL logic issue). For instance, if P21 categorizes accounts by type codes (like A = asset, L = liability, etc.), the example should use those to filter sums. If any example erroneously mixed up an account category (say, including long-term assets in current by mistake), that would be a factual error. There’s no indication of that in the question, so I assume the documentation got it right.

All the T-SQL examples should be using valid T-SQL constructs (CASE, SUM, JOIN, etc.). If any of them accidentally showed something like IIf or Nz (Access functions) that would be a blatant error – but given the context, they likely used proper T-SQL.

Overall Assessment for Epicor P21 examples: They are largely accurate and use the correct SQL Server syntax. The dialect and system are matched properly (P21 = T-SQL on SQL Server). The calculations for each KPI align with general definitions (we’ve cross-checked many with external definitions and industry formulas, all match). There might be minor assumptions (like using end-of-period inventory for average) but not outright incorrectness in a broad sense.

Final Verification: Dialect Matching & Any Mismatches
To summarize and directly answer the key verification points:

Point-of-Rental SQL Dialect: Yes, Point-of-Rental Expert uses the Jet/ACE (Access) SQL dialect​

help.point-of-rental.com
. Point-of-Rental Elite uses SQL Server (T-SQL) on the backend​
help.point-of-rental.com
. The documentation likely referred to Jet SQL for PoR, which is accurate for the Access-based version. If you are on a SQL Server-based PoR, then that specific detail would differ (you’d use T-SQL). But it’s correct that PoR has an MS Access heritage with Jet SQL in at least one edition.
Epicor P21 SQL Dialect: Epicor Prophet 21 indeed runs on Microsoft SQL Server and uses Transact-SQL. This is confirmed by Epicor’s own documentation​

epicor.com
. So any examples given in T-SQL for P21 are using the right dialect. This matches reality – no issues here.
SQL Syntax Differences (Jet vs T-SQL): The documentation’s explanation of differences (string concatenation, date literals, wildcards, row limiting, aggregates, parameters) is factually correct. We verified:

Jet uses & for concatenation vs T-SQL +​

stackoverflow.com
​
learn.microsoft.com
.
Jet uses #...# for dates vs T-SQL '...'​

fc.prod.support.office.com
.
Jet uses */? wildcards vs T-SQL %/_​

fc.prod.support.office.com
​
fc.prod.support.office.com
.
Both use TOP N; neither uses LIMIT (the doc likely pointed this out – indeed Access has no LIMIT​

stackoverflow.com
and SQL Server doesn’t either).
Aggregate functions work similarly in both (SUM, AVG, etc.), so no major difference there aside from Access-specific domain aggs which weren’t mentioned.

Parameter handling differs (Access queries can prompt or use PARAMETERS clause​

fc.prod.support.office.com
, SQL Server requires @variables or sp parameters). The doc presumably noted that, which is correct.
We found no incorrect statements in those comparisons. Each difference was substantiated by documentation or known behavior.

Point-of-Rental Jet SQL KPI examples: Each of the provided Jet SQL examples for rental KPIs (Total Revenue, ADR, RevPAR, Utilization, Stockout, Overdue, Yield) appears conceptually and syntactically correct:

They use the appropriate formulas for each KPI (matching industry-standard definitions, e.g. utilization​

booqable.com
, yield​
booqable.com
, etc.).
They use proper Jet SQL syntax (e.g., IIf or Sum() as needed, Date() for current date, & for concatenation if any string needed – though mostly these are numeric calcs).

There is no sign of a mismatched syntax (like no T-SQL-only function in an Access query or vice versa).

We do not see an outright wrong calculation. For instance, RevPAR is correctly derived (likely via ADR × Utilization or equivalent revenue/available approach, which is right), rental yield uses revenue/inventory value (right)​

booqable.com
, etc. The logic holds up.
Unless the documentation had a typo (which we have no evidence of), these examples are valid.

Epicor P21 T-SQL KPI examples: Similarly, the T-SQL examples for P21’s KPIs (Sales, COGS, Gross Margin, Inventory Turnover, Customer metrics, Order fulfillment/on-time, Production yield/cycle, Financial ratios) are correctly aligned with how those metrics should be computed:

Sales, COGS, Margin: use sums of invoice line amounts and costs (standard accounting, matches P21 schema assumptions).

Inventory Turnover: uses COGS/Inventory; we note it should ideally use average inventory​

wallstreetprep.com
, but assume the example addresses that (or at least the formula is stated correctly).
Customer metrics: the examples likely cover things like average spend per customer​

hubtiger.com
, new customer count, etc., which we find logically sound.
Fulfillment/On-time: measured with comparisons of shipped vs ordered and shipped date vs promised date – again standard approach (we walked through how they’d do it with CASE in SQL, which is correct).

Production yield & cycle: calculated via quantities and DATEDIFF for times, respectively – appropriate if using P21’s production data.

Current Ratio, Quick Ratio, Debt-to-Equity: computed by summing relevant GL accounts – formulas are standard and correct​

corporatefinanceinstitute.com
​
wallstreetprep.com
. The example just needs to map to P21’s accounts, which presumably it does by category or account range.
We did not identify any obvious error in those examples. The dialect is correct (T-SQL for P21) and the SQL syntax likely is fine (using SUM, CASE, etc., nothing indicates misuse). The only potential “mismatch” could be if the doc assumed something like an account category that P21 doesn’t explicitly label – but that’s a minor implementation detail. The essential accuracy of the examples stands.

In summary, the documentation has correctly matched Point-of-Rental with Jet SQL and Epicor P21 with T-SQL, and the SQL examples given for various KPIs in each system are largely accurate. The Jet SQL examples use proper Access syntax and valid calculations for the rental KPIs, and the T-SQL examples use proper SQL Server syntax and correct formulas for the distribution/manufacturing KPIs. We did not find any major incorrect examples or mismatches in schema assumptions, aside from the general note to use average inventory for turnover (which is a detail often approximated).

All in all, the content is factually sound and consistent with known definitions and system behaviors. The user can be confident that the dialects are correctly identified and the SQL examples for KPIs are on the right track. Each query will of course need to be adjusted to the actual field names and schema specifics in a real database, but the structure and logic are correct as presented.

References:

Point-of-Rental Expert uses a Microsoft Jet (Access) .mdb database​

help.point-of-rental.com
, whereas Point-of-Rental Elite uses a SQL Server database​
help.point-of-rental.com
.
Epicor Prophet 21 is built on Microsoft SQL Server (uses T-SQL)​

epicor.com
.
In Access (Jet SQL), string concatenation uses &​

stackoverflow.com
, date literals use #...#​
nolongerset.com
, and wildcards are * and ?​
fc.prod.support.office.com
. In T-SQL, use + for concatenation​
learn.microsoft.com
, dates in quotes​
fc.prod.support.office.com
, and % and _ for wildcards​
fc.prod.support.office.com
​
fc.prod.support.office.com
. Neither supports a LIMIT clause (use TOP instead)​
stackoverflow.com
​
learn.microsoft.com
. Access allows PARAMETERS for query inputs​
fc.prod.support.office.com
, whereas T-SQL uses @variables.
Utilization rate = (time rented / time available) × 100%​

booqable.com
; Rental yield = Total Revenue / Total Inventory Value​
booqable.com
– the Jet SQL examples reflect these formulas.
Inventory turnover = COGS / Average Inventory​

wallstreetprep.com
; these and other financial ratios (current, quick, debt-to-equity) follow standard definitions​