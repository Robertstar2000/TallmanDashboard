/**
 * Fix SQL Expressions Script
 * 
 * This script reads the failed-sql-expressions.txt file generated by the SQL expression tests
 * and attempts to fix the failing SQL expressions by testing them against the actual database.
 * It also tries alternative table names and syntax variations based on P21Tables.md and PORTables.md.
 * 
 * Usage: node tests/fix-sql-expressions.js [--use-database] [--update-database]
 * 
 * Options:
 *   --use-database     Get SQL expressions directly from the database instead of failed-sql-expressions.txt
 *   --update-database  Update the database with fixed expressions
 */

const fs = require('fs');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');

// Import database handlers
const dbHandlers = require('./sql-expressions/db-handlers');
const sqlAlternatives = require('./sql-expressions/sql-alternatives');

// Configuration
const config = {
  failedExpressionsPath: path.join(__dirname, 'failed-sql-expressions.txt'),
  fixedExpressionsPath: path.join(__dirname, 'fixed-sql-expressions.txt'),
  dbPath: path.join(__dirname, '..', 'data', 'dashboard.db'),
  initPath: path.join(__dirname, '..', 'data', 'dashboard-init.json'),
  p21: {
    dsn: process.env.P21_DSN || 'P21Live',
    username: process.env.P21_USERNAME || '',
    password: process.env.P21_PASSWORD || ''
  },
  por: {
    filePath: process.env.POR_FILE_PATH || '\\\\ts03\\POR\\POR.MDB'
  }
};

/**
 * Parse the failed expressions file
 * @returns {Promise<Array>} Failed expressions
 */
async function parseFailedExpressions() {
  // First check if we should get expressions directly from the database
  const useDatabase = process.argv.includes('--use-database');
  
  if (useDatabase) {
    return await getFailedExpressionsFromDatabase();
  }
  
  // Otherwise, parse from the failed expressions file
  if (!fs.existsSync(config.failedExpressionsPath)) {
    console.log(`Failed expressions file not found: ${config.failedExpressionsPath}`);
    return [];
  }
  
  const content = fs.readFileSync(config.failedExpressionsPath, 'utf8');
  const expressions = [];
  
  // Split the content by double newlines to separate expressions
  const blocks = content.split('\n\n');
  
  for (const block of blocks) {
    if (!block.trim()) continue;
    
    const lines = block.split('\n');
    const expression = {
      file: '',
      group: '',
      error: '',
      sql: ''
    };
    
    for (const line of lines) {
      if (line.startsWith('# File:')) {
        expression.file = line.substring('# File:'.length).trim();
      } else if (line.startsWith('# Group:')) {
        expression.group = line.substring('# Group:'.length).trim();
      } else if (line.startsWith('# Error:')) {
        expression.error = line.substring('# Error:'.length).trim();
      } else if (line.startsWith('/* Chart Group:')) {
        expression.group = line.match(/\/\* Chart Group: (.*?) \*\//)[1];
      } else if (line.trim() && !line.startsWith('#') && !line.startsWith('/*')) {
        expression.sql = line.trim();
      }
    }
    
    if (expression.group && (expression.error || !expression.sql)) {
      expressions.push(expression);
    }
  }
  
  return expressions;
}

/**
 * Get failed expressions directly from the database
 * @returns {Promise<Array>} Failed expressions
 */
async function getFailedExpressionsFromDatabase() {
  console.log('Getting SQL expressions directly from the database...');
  
  try {
    // Open the database connection
    const db = await open({
      filename: config.dbPath,
      driver: sqlite3.Database
    });
    
    console.log('Connected to the database');
    
    // Get all chart data
    const chartData = await db.all(`
      SELECT 
        id, 
        chart_group, 
        chart_name, 
        variable_name,
        expression_type,
        sql_expression
      FROM chart_data
      ORDER BY chart_group, chart_name, variable_name
    `);
    
    // Close the database connection
    await db.close();
    
    console.log(`Found ${chartData.length} total chart data entries`);
    
    // Filter for entries that need SQL expressions fixed
    const expressions = [];
    
    for (const row of chartData) {
      const sql = row.sql_expression;
      
      if (!sql || sql.trim() === '' || sql.trim().toLowerCase() === 'null') {
        expressions.push({
          id: row.id,
          group: row.chart_group,
          variable: row.variable_name,
          chartName: row.chart_name,
          isPOR: row.chart_group && row.chart_group.toLowerCase() === 'por overview',
          sql: null,
          error: 'Missing SQL expression'
        });
      } else if (sql.includes('FIXME') || sql.includes('TODO')) {
        expressions.push({
          id: row.id,
          group: row.chart_group,
          variable: row.variable_name,
          chartName: row.chart_name,
          isPOR: row.chart_group && row.chart_group.toLowerCase() === 'por overview',
          sql: sql,
          error: 'SQL contains FIXME or TODO marker'
        });
      }
    }
    
    console.log(`Found ${expressions.length} expressions that need to be fixed`);
    
    return expressions;
  } catch (error) {
    console.error(`Error reading SQL expressions from database: ${error.message}`);
    return [];
  }
}

/**
 * Save fixed expressions to a file
 * @param {Array} fixedExpressions Fixed expressions
 */
function saveFixedExpressions(fixedExpressions) {
  // Clear the file if it exists
  if (fs.existsSync(config.fixedExpressionsPath)) {
    fs.unlinkSync(config.fixedExpressionsPath);
  }
  
  // If no fixed expressions, create an empty file
  if (fixedExpressions.length === 0) {
    fs.writeFileSync(config.fixedExpressionsPath, '# No fixed SQL expressions\n');
    return;
  }
  
  // Write fixed expressions to file
  const content = fixedExpressions.map(expr => {
    return `# File: ${expr.file || 'N/A'}\n# Group: ${expr.group}\n# Variable: ${expr.variable || 'N/A'}\n# Fixed: ${expr.fixed}\n# Reason: ${expr.reason || 'N/A'}\n# Value: ${expr.value || 'N/A'}\n${expr.sql}\n\n`;
  }).join('');
  
  fs.writeFileSync(config.fixedExpressionsPath, content);
  console.log(`Fixed SQL expressions saved to: ${config.fixedExpressionsPath}`);
}

/**
 * Update database with fixed expressions
 * @param {Array} fixedExpressions Fixed expressions
 */
async function updateDatabase(fixedExpressions) {
  const successfullyFixed = fixedExpressions.filter(expr => expr.fixed);
  
  if (successfullyFixed.length === 0) {
    console.log('No expressions were successfully fixed. Database will not be updated.');
    return;
  }
  
  try {
    // Open the database connection
    const db = await open({
      filename: config.dbPath,
      driver: sqlite3.Database
    });
    
    console.log('Connected to the database');
    
    // Begin transaction
    await db.run('BEGIN TRANSACTION');
    
    let updatedCount = 0;
    
    // Update each fixed expression
    for (const expr of successfullyFixed) {
      // Get the ID from the file path or directly from the expression
      let id = expr.id;
      
      if (!id) {
        const idMatch = (expr.file || '').match(/id\s*=\s*['"]?([^'"]+)['"]?/i);
        id = idMatch ? idMatch[1] : null;
      }
      
      if (!id) {
        console.log(`Could not extract ID from file path: ${expr.file}`);
        continue;
      }
      
      // Update the database
      try {
        await db.run(`
          UPDATE chart_data 
          SET sql_expression = ? 
          WHERE id = ?
        `, [expr.sql, id]);
        
        updatedCount++;
        console.log(`Updated SQL expression for ID ${id}, Group: ${expr.group}`);
      } catch (error) {
        console.error(`Error updating SQL expression for ID ${id}:`, error.message);
      }
    }
    
    // Commit transaction
    await db.run('COMMIT');
    
    // Close the database connection
    await db.close();
    
    console.log(`\nSuccessfully updated ${updatedCount} SQL expressions in the database`);
    
    // Also update the initialization file if it exists
    await updateInitializationFile(successfullyFixed);
    
  } catch (error) {
    console.error('Error updating database:', error);
  }
}

/**
 * Update the initialization file with fixed expressions
 * @param {Array} fixedExpressions Fixed expressions
 */
async function updateInitializationFile(fixedExpressions) {
  if (!fs.existsSync(config.initPath)) {
    console.log('Initialization file not found, skipping update.');
    return;
  }
  
  try {
    // Make a backup of the init file first
    const backupPath = `${config.initPath}.backup`;
    fs.copyFileSync(config.initPath, backupPath);
    console.log(`Backed up initialization file to: ${backupPath}`);
    
    // Read the initialization file
    const initData = JSON.parse(fs.readFileSync(config.initPath, 'utf8'));
    
    if (!Array.isArray(initData)) {
      console.error('Initialization file does not contain an array.');
      return;
    }
    
    let updatedCount = 0;
    
    // Update each fixed expression in the initialization file
    for (const expr of fixedExpressions) {
      const id = expr.id;
      
      if (!id) continue;
      
      // Find the corresponding entry in the init file
      const entry = initData.find(item => item.id === id || item.id === parseInt(id));
      
      if (entry) {
        // Only update the SQL expression, don't modify any other part of the structure
        entry.sql_expression = expr.sql;
        updatedCount++;
      }
    }
    
    // Write the updated data back to the file, preserving the original formatting
    fs.writeFileSync(config.initPath, JSON.stringify(initData, null, 2));
    
    console.log(`Successfully updated ${updatedCount} SQL expressions in the initialization file`);
  } catch (error) {
    console.error('Error updating initialization file:', error);
  }
}

/**
 * Execute P21 SQL query with retry logic
 * @param {object} connection P21 connection
 * @param {string} sql SQL query
 * @returns {Promise<object>} Query result
 */
async function executeP21QueryWithRetry(connection, sql) {
  const maxRetries = 3;
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      console.log(`Executing P21 SQL (attempt ${retries + 1}/${maxRetries})...`);
      const result = await connection.query(sql);
      
      if (result && result.length > 0 && result[0].value !== undefined) {
        return { success: true, value: result[0].value };
      }
      
      return { success: false, reason: 'No results returned' };
    } catch (error) {
      console.log(`P21 query failed (attempt ${retries + 1}/${maxRetries}): ${error.message}`);
      retries++;
      
      if (retries >= maxRetries) {
        return { success: false, reason: error.message };
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

/**
 * Execute POR SQL query with retry logic
 * @param {object} reader POR reader
 * @param {string} sql SQL query
 * @returns {Promise<object>} Query result
 */
async function executePORQueryWithRetry(reader, sql) {
  const maxRetries = 3;
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      console.log(`Executing POR SQL (attempt ${retries + 1}/${maxRetries})...`);
      const result = await reader.query(sql);
      
      if (result && result.length > 0 && result[0].value !== undefined) {
        return { success: true, value: result[0].value };
      }
      
      return { success: false, reason: 'No results returned' };
    } catch (error) {
      console.log(`POR query failed (attempt ${retries + 1}/${maxRetries}): ${error.message}`);
      retries++;
      
      if (retries >= maxRetries) {
        return { success: false, reason: error.message };
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

/**
 * Print a formatted summary of fixed expressions by chart group
 * @param {Array} expressions All expressions
 * @param {Array} fixedExpressions Fixed expressions
 */
function printFixedSummaryByGroup(expressions, fixedExpressions) {
  // Group expressions by chart group
  const groups = {};
  
  for (const expr of expressions) {
    const group = expr.group || 'Unknown';
    if (!groups[group]) {
      groups[group] = {
        total: 0,
        fixed: 0
      };
    }
    
    groups[group].total++;
  }
  
  // Count fixed expressions by group
  for (const expr of fixedExpressions) {
    if (expr.fixed) {
      const group = expr.group || 'Unknown';
      if (groups[group]) {
        groups[group].fixed++;
      }
    }
  }
  
  // Print summary
  console.log('\n--- Summary by Chart Group ---');
  console.log('Chart Group'.padEnd(20) + 'Fixed'.padEnd(10) + 'Total'.padEnd(10) + '% Fixed');
  console.log('-'.repeat(50));
  
  let totalFixed = 0;
  let totalExpressions = 0;
  
  for (const group of Object.keys(groups).sort()) {
    const { fixed, total } = groups[group];
    const percent = total > 0 ? Math.round((fixed / total) * 100) : 0;
    
    console.log(`${group.padEnd(20)}${fixed.toString().padEnd(10)}${total.toString().padEnd(10)}${percent}%`);
    
    totalFixed += fixed;
    totalExpressions += total;
  }
  
  // Print totals
  const totalPercent = totalExpressions > 0 ? Math.round((totalFixed / totalExpressions) * 100) : 0;
  console.log('-'.repeat(50));
  console.log(`TOTAL`.padEnd(20) + `${totalFixed}`.padEnd(10) + `${totalExpressions}`.padEnd(10) + `${totalPercent}%`);
}

/**
 * Main function to fix SQL expressions
 */
async function fixSqlExpressions() {
  console.log('Starting SQL Expression Fixer...');
  
  // Parse failed expressions
  const expressions = await parseFailedExpressions();
  console.log(`Found ${expressions.length} expressions to fix`);
  
  if (expressions.length === 0) {
    console.log('No expressions to fix. Exiting.');
    return;
  }
  
  // Connect to databases
  const p21Connection = await dbHandlers.connectToP21(config.p21);
  const porReader = await dbHandlers.connectToPOR(config.por);
  
  // Fix expressions
  const fixedExpressions = [];
  
  // Process expressions in batches to avoid overloading the database
  const batchSize = 10;
  const batches = Math.ceil(expressions.length / batchSize);
  
  for (let i = 0; i < batches; i++) {
    const start = i * batchSize;
    const end = Math.min(start + batchSize, expressions.length);
    const batch = expressions.slice(start, end);
    
    console.log(`\nProcessing batch ${i + 1}/${batches} (expressions ${start + 1}-${end})...`);
    
    // Process each expression in the batch
    for (const expr of batch) {
      console.log(`\nFixing expression for group: ${expr.group}, variable: ${expr.variable || 'unknown'}`);
      
      // Skip if no SQL and we can't determine the type
      if (!expr.sql && expr.isPOR === undefined) {
        fixedExpressions.push({
          ...expr,
          fixed: false,
          reason: 'Cannot determine if this is a P21 or POR expression'
        });
        continue;
      }
      
      // Determine if it's a POR expression
      const isPOR = expr.isPOR !== undefined ? expr.isPOR : 
                   expr.group.toLowerCase().includes('por');
      
      if (isPOR) {
        // Fix POR expression
        if (porReader) {
          try {
            // Try the original SQL first
            if (expr.sql) {
              console.log('Trying original POR SQL...');
              const result = await executePORQueryWithRetry(porReader, expr.sql);
              
              if (result.success) {
                fixedExpressions.push({
                  ...expr,
                  fixed: true,
                  value: result.value,
                  reason: `Original SQL executed successfully with value: ${result.value}`
                });
                continue;
              }
            }
            
            // Try alternative table names and syntax variations
            if (expr.sql) {
              console.log('Trying POR alternatives...');
              const alternativesResult = await sqlAlternatives.tryPORAlternatives(
                expr.sql,
                porReader,
                executePORQueryWithRetry
              );
              
              if (alternativesResult.success) {
                fixedExpressions.push({
                  ...expr,
                  sql: alternativesResult.sql,
                  fixed: true,
                  value: alternativesResult.value,
                  reason: `Alternative SQL executed successfully with value: ${alternativesResult.value}`
                });
                continue;
              }
            }
            
            // Generate new SQL based on chart group
            console.log('Generating new POR SQL based on chart group...');
            const generatedSql = dbHandlers.generatePORSqlForGroup(expr.group);
            
            if (generatedSql) {
              const result = await executePORQueryWithRetry(porReader, generatedSql);
              
              if (result.success) {
                fixedExpressions.push({
                  ...expr,
                  sql: generatedSql,
                  fixed: true,
                  value: result.value,
                  reason: `Generated SQL executed successfully with value: ${result.value}`
                });
                continue;
              }
            }
            
            // Failed to fix
            fixedExpressions.push({
              ...expr,
              fixed: false,
              reason: 'All POR SQL attempts failed'
            });
          } catch (error) {
            console.error(`Error fixing POR expression: ${error.message}`);
            fixedExpressions.push({
              ...expr,
              fixed: false,
              reason: `Error: ${error.message}`
            });
          }
        } else {
          fixedExpressions.push({
            ...expr,
            fixed: false,
            reason: 'POR database connection not available'
          });
        }
      } else {
        // Fix P21 expression
        if (p21Connection) {
          try {
            // Try the original SQL first
            if (expr.sql) {
              console.log('Trying original P21 SQL...');
              const result = await executeP21QueryWithRetry(p21Connection, expr.sql);
              
              if (result.success) {
                fixedExpressions.push({
                  ...expr,
                  fixed: true,
                  value: result.value,
                  reason: `Original SQL executed successfully with value: ${result.value}`
                });
                continue;
              }
            }
            
            // Try alternative table names and syntax variations
            if (expr.sql) {
              console.log('Trying P21 alternatives...');
              const alternativesResult = await sqlAlternatives.tryP21Alternatives(
                expr.sql,
                p21Connection,
                executeP21QueryWithRetry
              );
              
              if (alternativesResult.success) {
                fixedExpressions.push({
                  ...expr,
                  sql: alternativesResult.sql,
                  fixed: true,
                  value: alternativesResult.value,
                  reason: `Alternative SQL executed successfully with value: ${alternativesResult.value}`
                });
                continue;
              }
            }
            
            // Generate new SQL based on chart group
            console.log('Generating new P21 SQL based on chart group...');
            const generatedSql = dbHandlers.generateP21SqlForGroup(expr.group);
            
            if (generatedSql) {
              const result = await executeP21QueryWithRetry(p21Connection, generatedSql);
              
              if (result.success) {
                fixedExpressions.push({
                  ...expr,
                  sql: generatedSql,
                  fixed: true,
                  value: result.value,
                  reason: `Generated SQL executed successfully with value: ${result.value}`
                });
                continue;
              }
            }
            
            // Failed to fix
            fixedExpressions.push({
              ...expr,
              fixed: false,
              reason: 'All P21 SQL attempts failed'
            });
          } catch (error) {
            console.error(`Error fixing P21 expression: ${error.message}`);
            fixedExpressions.push({
              ...expr,
              fixed: false,
              reason: `Error: ${error.message}`
            });
          }
        } else {
          fixedExpressions.push({
            ...expr,
            fixed: false,
            reason: 'P21 database connection not available'
          });
        }
      }
    }
  }
  
  // Print summary
  const fixedCount = fixedExpressions.filter(expr => expr.fixed).length;
  console.log(`\nFixed ${fixedCount} / ${expressions.length} expressions (${Math.round((fixedCount / expressions.length) * 100)}%)`);
  
  // Print detailed summary by chart group
  printFixedSummaryByGroup(expressions, fixedExpressions);
  
  // Save fixed expressions to file
  saveFixedExpressions(fixedExpressions);
  
  // Update database if --update-database was specified
  if (process.argv.includes('--update-database')) {
    await updateDatabase(fixedExpressions);
  } else {
    console.log('\nTo update the database with fixed expressions, run with --update-database flag');
  }
}

// Run the main function
fixSqlExpressions().catch(error => {
  console.error('Unhandled error in SQL expression fixer:', error);
  process.exit(1);
});

