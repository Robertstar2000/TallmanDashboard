# PowerShell script for targeted SQL replacement with detailed logging\n# This script focuses on files shown in the search results\n\n$rootDir = \"c:\\Users\\BobM\\CascadeProjects\\TallmanDashboard_new\"\n$logFile = \"$rootDir\\sql_replacement_log.txt\"\n\n# Initialize log file\n\"SQL Expression Replacement Log - $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\" | Out-File -FilePath $logFile\n\"==========================================================\" | Out-File -FilePath $logFile -Append\n\n# Define specific files to focus on based on search results\n$targetFiles = @(\n    \"lib\\db\\sqlite.ts\", \n    \"lib\\db\\single-source-data.ts\",\n    \"db-schema-check.txt\",\n    \"lib\\db\\DBTables.txt\",\n    \"lib\\db\\SQLiteSchema.ts\",\n    \"lib\\db\\fix-sql-expressions.js\",\n    \"lib\\db\\connections.ts\",\n    \"lib\\db\\p21-connection-diagnostics.ts\",\n    \"lib\\db\\test-db.ts\"\n)\n\n# Process each specific target file\nforeach ($relativeFilePath in $targetFiles) {\n    $filePath = Join-Path -Path $rootDir -ChildPath $relativeFilePath\n    \n    if (Test-Path $filePath) {\n        \"Processing file: $relativeFilePath\" | Out-File -FilePath $logFile -Append\n        \n        try {\n            $content = Get-Content -Path $filePath -Raw -ErrorAction Stop\n            $originalContent = $content\n            \n            # Count initial occurrences\n            $initialMatches = [regex]::Matches($content, 'sql|productionSql|sql').Count\n            \"  Initial references: $initialMatches\" | Out-File -FilePath $logFile -Append\n            \n            # Handle case variations and contexts\n            $replacements = @(\n                # General replacements\n                @{ Pattern = 'sql_expression'; Replacement = 'sql_expression' },\n                @{ Pattern = 'sql(?!_expression)'; Replacement = 'sql_expression' },\n                @{ Pattern = 'productionSqlExpression'; Replacement = 'sqlExpression' },\n                @{ Pattern = 'productionSql(?!Expression)'; Replacement = 'sqlExpression' },\n                @{ Pattern = 'sql_EXPRESSION'; Replacement = 'SQL_EXPRESSION' },\n                @{ Pattern = 'sql'; Replacement = 'SQL_EXPRESSION' },\n                \n                # SQL contexts - matches in CREATE TABLE, INSERT, etc.\n                @{ Pattern = '\\s+sql_expression\\s+TEXT'; Replacement = ' sql_expression TEXT' },\n                @{ Pattern = '\\s+sql\\s+TEXT'; Replacement = ' sql_expression TEXT' },\n                \n                # Console.log contexts\n                @{ Pattern = 'console\\.log\\([^)]*sql'; Replacement = 'console.log($1sql_expression' },\n                \n                # Column names in queries\n                @{ Pattern = 'WHERE\\s+sql'; Replacement = 'WHERE sql_expression' },\n                @{ Pattern = 'AND\\s+sql'; Replacement = 'AND sql_expression' },\n                @{ Pattern = 'OR\\s+sql'; Replacement = 'OR sql_expression' },\n                @{ Pattern = 'SET\\s+sql'; Replacement = 'SET sql_expression' }\n            )\n            \n            # Apply each replacement\n            foreach ($replacement in $replacements) {\n                $before = $content\n                $content = $content -replace $replacement.Pattern, $replacement.Replacement\n                \n                if ($before -ne $content) {\n                    $matchCount = ($before | Select-String -Pattern $replacement.Pattern -AllMatches).Matches.Count\n                    \"  - Replaced '$($replacement.Pattern)' with '$($replacement.Replacement)' ($matchCount instances)\" | Out-File -FilePath $logFile -Append\n                }\n            }\n            \n            # Save changes if there were any\n            if ($content -ne $originalContent) {\n                Set-Content -Path $filePath -Value $content -NoNewline\n                \n                # Count final occurrences\n                $finalMatches = [regex]::Matches($content, 'sql|productionSql|sql').Count\n                \"  Final references: $finalMatches\" | Out-File -FilePath $logFile -Append\n                \"  Successfully updated file\" | Out-File -FilePath $logFile -Append\n                \n                Write-Host \"Updated $relativeFilePath\" -ForegroundColor Green\n            } else {\n                \"  No changes needed\" | Out-File -FilePath $logFile -Append\n            }\n        } catch {\n            \"  ERROR: $_\" | Out-File -FilePath $logFile -Append\n            Write-Host \"Error processing $relativeFilePath: $_\" -ForegroundColor Red\n        }\n        \n        \"\" | Out-File -FilePath $logFile -Append\n    } else {\n        \"File not found: $relativeFilePath\" | Out-File -FilePath $logFile -Append\n        \"\" | Out-File -FilePath $logFile -Append\n    }\n}\n\n# Now do a general search over all remaining files\nWrite-Host \"Checking remaining files for any sql references...\" -ForegroundColor Yellow\n\"\\nSearching all other files:\" | Out-File -FilePath $logFile -Append\n\n$allFiles = Get-ChildItem -Path $rootDir -Recurse -File | Where-Object {\n    $_.Extension -in @(\".ts\", \".tsx\", \".js\", \".jsx\", \".md\", \".txt\", \".json\", \".sql\", \".html\") -and\n    $_.FullName -notlike \"*\\node_modules\\*\" -and\n    $_.FullName -notlike \"*\\.git\\*\" -and\n    $_.FullName -notlike \"*\\.next\\*\" -and\n    -not ($targetFiles -contains $_.FullName.Substring($rootDir.Length).TrimStart('\\')) -and\n    $_.Length -lt 5MB\n}\n\n$filesWithMatches = 0\n\nforeach ($file in $allFiles) {\n    $relativePath = $file.FullName.Substring($rootDir.Length).TrimStart('\\')\n    \n    try {\n        $content = Get-Content -Path $file.FullName -Raw -ErrorAction SilentlyContinue\n        if ($null -eq $content) { continue }\n        \n        if ($content -match 'sql|productionSql|sql') {\n            $filesWithMatches++\n            \"Found matches in: $relativePath\" | Out-File -FilePath $logFile -Append\n            \n            $originalContent = $content\n            $content = $content -replace 'sql_expression', 'sql_expression'\n            $content = $content -replace 'sql', 'sql_expression'\n            $content = $content -replace 'productionSqlExpression', 'sqlExpression'\n            $content = $content -replace 'productionSql', 'sqlExpression'\n            $content = $content -replace 'sql_EXPRESSION', 'SQL_EXPRESSION'\n            $content = $content -replace 'sql', 'SQL_EXPRESSION'\n            \n            if ($content -ne $originalContent) {\n                Set-Content -Path $file.FullName -Value $content -NoNewline\n                \"  Updated file\" | Out-File -FilePath $logFile -Append\n                Write-Host \"Updated $relativePath\" -ForegroundColor Green\n            }\n        }\n    } catch {}\n}\n\n\"Found and processed $filesWithMatches additional files with matches\" | Out-File -FilePath $logFile -Append\n\n# Final verification\nWrite-Host \"\\nVerifying database schema in SQLite.ts...\" -ForegroundColor Cyan\n$sqliteFile = \"$rootDir\\lib\\db\\sqlite.ts\"\n\nif (Test-Path $sqliteFile) {\n    $content = Get-Content -Path $sqliteFile -Raw\n    $hasProductionSql = $content -match 'sql'\n    \n    \"\\nFinal check of SQLite.ts:\" | Out-File -FilePath $logFile -Append\n    \"  Contains 'sql': $hasProductionSql\" | Out-File -FilePath $logFile -Append\n    \n    if ($hasProductionSql) {\n        Write-Host \"WARNING: SQLite.ts still contains 'sql' references\" -ForegroundColor Red\n    } else {\n        Write-Host \"SQLite.ts has been cleaned of 'sql' references\" -ForegroundColor Green\n    }\n} else {\n    Write-Host \"SQLite.ts not found\" -ForegroundColor Red\n}\n\n# Summary\nWrite-Host \"\\nReplacement complete. See log file for details: $logFile\" -ForegroundColor Cyan\nWrite-Host \"Please restart your development server to apply all changes.\" -ForegroundColor Yellow\n
