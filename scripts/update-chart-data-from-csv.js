// Script to update complete-chart-data.ts file with data from MasterSQLTable.csv
const fs = require('fs');
const path = require('path');

// File paths
const csvFilePath = path.join(__dirname, 'MasterSQLTable.csv');
const outputFilePath = path.join(__dirname, '..', 'lib', 'db', 'complete-chart-data.ts');
const backupFilePath = path.join(__dirname, '..', 'lib', 'db', 'complete-chart-data.backup.ts');

// Read the CSV file
console.log(`Reading CSV data from: ${csvFilePath}`);
const csvData = fs.readFileSync(csvFilePath, 'utf8');

// Parse CSV data manually to handle the specific format with tabs and multiple spaces
function parseCSV(csvText) {
  const lines = csvText.split('\n').filter(line => line.trim() !== '');
  
  // First line contains headers
  const headerLine = lines[0];
  const headerParts = headerLine.split(',');
  
  // Extract clean headers
  const headers = [];
  for (let i = 0; i < headerParts.length; i++) {
    // Clean up the header by removing tabs and extra spaces
    const cleanHeader = headerParts[i].replace(/\t/g, '').trim();
    headers.push(cleanHeader);
  }
  
  const records = [];
  
  // Process each data line
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const parts = line.split(',');
    
    const record = {};
    for (let j = 0; j < headers.length && j < parts.length; j++) {
      // Clean up the value by removing tabs and extra spaces
      const cleanValue = parts[j].replace(/\t/g, '').trim();
      record[headers[j]] = cleanValue;
    }
    
    records.push(record);
  }
  
  return records;
}

// Parse the CSV data
const records = parseCSV(csvData);
console.log(`Parsed ${records.length} records from CSV`);

// Read the current complete-chart-data.ts file to get the structure
console.log(`Reading current chart data from: ${outputFilePath}`);
const currentFileContent = fs.readFileSync(outputFilePath, 'utf8');

// Extract the import statement and comments at the top
const headerMatch = currentFileContent.match(/^(import.*?\n\n\/\/.*?\n\/\/.*?\n\nexport const initialSpreadsheetData)/s);
const header = headerMatch ? headerMatch[1] : 'import type { SpreadsheetRow } from \'./types\';\n\n// This file was auto-generated by the update-chart-data-from-csv.js script\n// Last updated: ' + new Date().toISOString() + '\n\nexport const initialSpreadsheetData';

// Extract the footer (export statement at the bottom)
const footerMatch = currentFileContent.match(/(\/\/ Export.*?\];)$/s);
const footer = footerMatch ? footerMatch[1] : '\n\n// Export the combined data\nexport const combinedData = [...initialSpreadsheetData];\n';

// Create a backup of the current file
console.log(`Creating backup at: ${backupFilePath}`);
fs.writeFileSync(backupFilePath, currentFileContent);

// Format the CSV data into the required structure
const formattedData = records.map(record => {
  // Extract the column values, handling potential undefined values
  const id = record['ID'] || '';
  const name = record['Name'] || '';
  const chartGroup = record['Chart Group'] || '';
  const variableName = record['Variable Name'] || '';
  const serverName = record['Server Name'] || '';
  const value = record['Value'] || '0';
  const tableName = record['Table Name'] || 'TBD';
  const sqlExpression = record['SQL Expression'] || '';
  const productionSqlExpression = record['Production SQL Expression'] || '';

  // Format the name to match the pattern in the existing file
  // Example: "AR Aging - Current - Amount Due"
  let formattedName = name;
  if (!name.includes(' - ')) {
    // Try to format based on chart group and variable name
    const parts = name.split(' ');
    if (parts.length >= 2) {
      // Extract the variable and step from the name or variable name
      let variable = '';
      let step = '';
      
      if (variableName.includes(',')) {
        const varParts = variableName.split(',');
        variable = varParts[0].trim();
        step = varParts[1].trim();
      } else {
        // Try to extract from the name
        const lastWord = parts[parts.length - 1];
        variable = lastWord;
        step = parts.slice(0, -1).join(' ');
      }
      
      formattedName = `${chartGroup} - ${step} - ${variable}`;
    }
  }

  // Format the chartName to match the pattern (same as chartGroup)
  const chartName = chartGroup;

  // Create a properly formatted variableName if it's not already
  let formattedVariableName = variableName;
  if (variableName.includes(',')) {
    const varParts = variableName.split(',');
    formattedVariableName = `${varParts[0].trim()} ${varParts[1].trim()}`;
  }

  // Set calculation type (default to "number")
  const calculation = "number";

  // Set the lastUpdated timestamp
  const lastUpdated = new Date().toISOString();

  // Return the formatted data object
  return {
    id,
    name: formattedName,
    chartName,
    chartGroup,
    variableName: formattedVariableName,
    serverName,
    value,
    tableName,
    calculation,
    sqlExpression,
    productionSqlExpression,
    lastUpdated
  };
});

// Generate the new file content
const dataString = JSON.stringify(formattedData, null, 2)
  .replace(/\[/g, '[\n  ')
  .replace(/\]/g, '\n]')
  .replace(/},/g, '},\n  ')
  .replace(/}$/m, '}\n');

const newFileContent = `${header}: SpreadsheetRow[] = ${dataString};\n\n${footer}`;

// Write the updated content to the file
console.log(`Writing updated data to: ${outputFilePath}`);
fs.writeFileSync(outputFilePath, newFileContent);

console.log('Chart data has been successfully updated from the CSV file.');
