import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { parse } from 'csv-parse/sync'; // Import sync parser

// Define __dirname for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define the paths
const csvInputPath = path.resolve(__dirname, 'components', 'ui', 'SeedData.csv'); // New CSV source
const tsOutputPath = path.resolve(__dirname, 'lib', 'db', 'single-source-data.ts'); // Output TS file

// Main function to perform the conversion
async function rebuildSingleSourceData() {
  console.log(`Reading data from: ${csvInputPath}`);
  try {
    // Read the CSV file
    const csvData = await fs.readFile(csvInputPath, 'utf-8');

    // Parse the CSV data using headers
    const sourceData = parse(csvData, {
      columns: true,          // Use the first line as header keys
      skip_empty_lines: true, // Skip empty lines
      trim: true              // Trim whitespace from values
    });

    if (!Array.isArray(sourceData)) {
      throw new Error('Parsed CSV data is not an array.');
    }

    console.log(`Found ${sourceData.length} items in CSV data.`);

    // Transform the data
    const transformedData = sourceData.map((item, index) => {
      // Validate essential fields from CSV
      if (typeof item.ID === 'undefined' || item.ID === null || item.ID === '') {
         console.warn(`Item at index ${index} (CSV row ${index + 2}) is missing 'ID'. Skipping.`);
         return null; // Skip this item
      }
       // Use 'Production SQL Expression' directly from CSV
       if (!item['Production SQL Expression']) {
           console.warn(`Item with ID ${item.ID} is missing 'Production SQL Expression'. Setting to placeholder.`);
           item['Production SQL Expression'] = '-- MISSING SQL EXPRESSION';
       }
       // Check calculation type
       if (!item.Calculation) {
           console.warn(`Item with ID ${item.ID} is missing 'Calculation'. Setting to empty string.`);
           item.Calculation = '';
       }

      // Normalize calculation type
      let calculationType = item.Calculation || ''; // Default to empty string if missing
      const upperCalc = calculationType.toUpperCase();
      if (['SUM', 'COUNT', 'AVG', 'LATEST'].includes(upperCalc)) {
        calculationType = upperCalc;
      } else if (calculationType) {
        console.warn(`Item with ID ${item.ID} has unknown calculation type: ${calculationType}. Keeping original case.`);
      }

      // Map CSV columns to the target structure
      const transformedItem = {
        rowId: String(item.ID),
        chartGroup: item['Chart Group'] || '',
        variableName: item['Variable Name'] || '',
        DataPoint: item.Name || '', // Using 'Name' column from CSV for DataPoint
        serverName: item['Server Name'] || '',
        tableName: item['Table Name'] || '',
        productionSqlExpression: item['Production SQL Expression'] || '-- NO SQL EXPRESSION PROVIDED',
        calculationType: calculationType,
        chartName: item['Chart Name'] || item['Chart Group'] || '', // Use Chart Name, fallback to Chart Group
        axisStep: (item['Axis Step'] && String(item['Axis Step']).trim() !== '') ? String(item['Axis Step']).trim() : null,
      };

      return transformedItem;
    }).filter(item => item !== null); // Filter out skipped items

    console.log(`Transformed ${transformedData.length} items.`);

    // Generate the TypeScript file content
    let tsContent = `// Generated by rebuild-source-data.mjs script from ${path.basename(csvInputPath)}
// Do not edit this file manually, as changes will be overwritten.

import type { ChartDataRow } from './types';

// This type represents the static definition needed for each row.
// 'id' (db primary key), 'value', 'lastUpdated' are excluded as they are dynamic.
// Use Omit to define the specific structure we are exporting
export type SourceDataDefinition = Omit<ChartDataRow, 'id' | 'value' | 'lastUpdated'>;

export const singleSourceData: SourceDataDefinition[] = ${JSON.stringify(transformedData, null, 2)};
`;

    // Write the content to the output file
    await fs.writeFile(tsOutputPath, tsContent, 'utf-8');
    console.log(`Successfully rebuilt ${tsOutputPath} with ${transformedData.length} entries.`);

  } catch (error) {
    console.error('Error rebuilding single-source-data.ts:', error);
     if (error.code === 'INVALID_RECORD_LENGTH' || error.message.includes('Invalid Record Length')) {
         console.error("This might be due to inconsistent number of columns in the CSV file.");
     } else {
         console.error("An unexpected error occurred during the rebuild process.");
     }
  }
}

// Run the function
rebuildSingleSourceData();
