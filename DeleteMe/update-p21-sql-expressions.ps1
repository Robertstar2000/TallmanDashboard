# PowerShell script to update P21 SQL expressions in the restored file
$filePath = "c:\Users\BobM\CascadeProjects\TallmanDashboard_new\lib\db\complete-chart-data.ts"
$backupPath = "c:\Users\BobM\CascadeProjects\TallmanDashboard_new\lib\db\complete-chart-data.ts.before-update"
$tempFilePath = "c:\Users\BobM\CascadeProjects\TallmanDashboard_new\lib\db\complete-chart-data.temp.ts"

# Create a backup
Copy-Item -Path $filePath -Destination $backupPath -Force
Write-Host "Created backup at $backupPath"

# Read the current file content
$content = Get-Content -Path $filePath -Raw

# Create a new file for the updated content
$newContent = "import type { SpreadsheetRow } from './types';

// This file was auto-generated by the rebuild-chart-data-fixed.ps1 script
// Last updated: 2025-03-25T00:45:00.000Z

export const initialSpreadsheetData: SpreadsheetRow[] = [
"

# Process the file line by line
$lines = $content -split "`n"
$inP21Entry = $false
$currentEntry = ""
$p21Count = 0
$porCount = 0
$otherCount = 0

for ($i = 0; $i -lt $lines.Count; $i++) {
    $line = $lines[$i]
    
    # Check if we're starting a new entry
    if ($line -match '^\s*{') {
        $currentEntry = $line + "`n"
        $inP21Entry = $false
        continue
    }
    
    # Check if we're in a P21 entry
    if ($line -match '"serverName": "P21"') {
        $inP21Entry = $true
    }
    
    # Check if we're in a POR entry
    if ($line -match '"serverName": "POR"') {
        $inP21Entry = $false
    }
    
    # Add the line to the current entry
    $currentEntry += $line + "`n"
    
    # Check if we're ending an entry
    if ($line -match '^\s*}(,)?$') {
        # Process the entry based on whether it's P21 or not
        if ($inP21Entry) {
            # Extract the ID
            $idMatch = [regex]::Match($currentEntry, '"id": "(\d+)"')
            if ($idMatch.Success) {
                $id = $idMatch.Groups[1].Value
                
                # Look for the matching entry in the provided SQL updates
                $newEntryMatch = [regex]::Match($newSqlUpdates, '{\s+"id": "' + $id + '"[\s\S]*?}')
                if ($newEntryMatch.Success) {
                    $newEntry = $newEntryMatch.Value
                    $newContent += "  " + $newEntry
                    if ($i -lt $lines.Count - 1 -and $lines[$i+1] -match '^\s*{') {
                        $newContent += ",`n"
                    } elseif ($i -lt $lines.Count - 1) {
                        $newContent += "`n"
                    }
                    $p21Count++
                } else {
                    # Keep the original entry if no update is found
                    $newContent += "  " + $currentEntry
                    $otherCount++
                }
            } else {
                # Keep the original entry if no ID is found
                $newContent += "  " + $currentEntry
                $otherCount++
            }
        } else {
            # Keep POR entries as they are
            $newContent += "  " + $currentEntry
            $porCount++
        }
        
        $currentEntry = ""
        $inP21Entry = $false
    }
}

# Close the array and add the export statement
$newContent += "];

// Export the combined data
export const combinedData = initialSpreadsheetData;
"

# Write the new content to a temporary file
Set-Content -Path $tempFilePath -Value $newContent

# Verify the temp file
$tempContent = Get-Content -Path $tempFilePath -Raw
$tempP21Count = [regex]::Matches($tempContent, '"serverName": "P21"').Count
$tempPorCount = [regex]::Matches($tempContent, '"serverName": "POR"').Count
$tempTotalCount = [regex]::Matches($tempContent, '"id": "[0-9]+"').Count

Write-Host "Temp file statistics:"
Write-Host "- Total entries: $tempTotalCount"
Write-Host "- P21 entries: $tempP21Count"
Write-Host "- POR entries: $tempPorCount"

# Check if the temp file has the expected number of entries
if ($tempTotalCount -ge 174 -and $tempPorCount -eq 48) {
    Copy-Item -Path $tempFilePath -Destination $filePath -Force
    Write-Host "Successfully updated P21 SQL expressions in $filePath"
    
    # Ensure the file ends with a single newline (fix lint issue)
    $finalContent = Get-Content -Path $filePath -Raw
    if ($finalContent.EndsWith("`n`n")) {
        # Remove extra newline at the end
        $finalContent = $finalContent.Substring(0, $finalContent.Length - 1)
        Set-Content -Path $filePath -Value $finalContent -NoNewline
        Add-Content -Path $filePath -Value ""  # Add a single newline at the end
        Write-Host "Fixed extra newline at the end of the file"
    } elseif (-not $finalContent.EndsWith("`n")) {
        # Add a newline if missing
        Add-Content -Path $filePath -Value ""
        Write-Host "Added missing newline at the end of the file"
    }
} else {
    Write-Host "Error: Temp file does not have the expected number of entries. Not replacing current file."
    exit 1
}

# Clean up
Remove-Item -Path $tempFilePath -Force
Write-Host "Removed temp file"

Write-Host "Processing summary:"
Write-Host "- P21 entries updated: $p21Count"
Write-Host "- POR entries preserved: $porCount"
Write-Host "- Other entries: $otherCount"
Write-Host "Done!"
